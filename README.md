# GCTree
JVM 垃圾收集技术研究

根搜索算法

![](https://i.imgur.com/C1BT8MT.png)

<pre>
对象存活判断
         1）引用计数法
            每个对象有一个引用的计数属性，新增一个引用时计数加1，引用释放的时候计数减一，
         计数为0的时候可以回收，此方法简单，但是无法解决对象的相互循环引用的问题。

         2）根搜索算法
            也叫可达性分析算法。
            从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有
         任何引用链时，则证明这个对象是不可用的。不可达对象。

            在Java中，GC Roots包括：
                                  1）虚拟机栈中引用的对象。
                                  2）方法区中类静态属性实体引用的对象。
                                  3）方法区中常量引用的对象。
                                  5）本地方法栈中JNI引用的对象。
</pre>

<pre>
无论通过引用计数法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判断对象
是否存活都与“引用”有关。

      Java中将引用分为
           1）强引用
              就是在程序代码中普遍存在的，例如Object obj = new Object();
              只要强引用还在，垃圾收集器就永远不会回收。

           2）软引用
              软引用用来描述一些还有用，但并不是必须的对象。对于软引用关联着的对象，在系统
           将要发生内存溢出之前，将会把这些对象列进回收范围之中并进行第二次回收，如果这次
           回收还是没有足够的内存，才会跑出内存溢出。

           3）弱引用
              弱引用也是用来描述非必须对象的，但是它的强度比弱引用更弱一些，被弱引用关联
           的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否
           足够，都会回收掉弱引用关联的对象。

           5）虚引用
              虚引用也称为幽灵引用，它是最弱的一种引用，一个对象是否有虚引用的存在，完全不
           会对其生存环境构成影响，为一个对象设置虚引用关联的唯一目的就是希望能在这个对象
           被收集器回收的时候收到一个系统通知。
</pre>

##垃圾收集算法

<pre>
标记清除算法
</pre>

<pre>
复制算法
</pre>

<pre>
标记压缩算法
</pre>

![](https://i.imgur.com/draRR1V.png)

<pre>
分代收集算法
</pre>

##垃圾收集器

<pre>
Serial 串行收集器
</pre>

<pre>
ParNew 并行收集器
</pre>

<pre>
Parallel Scavenge 并行清除收集器
</pre>

<pre>
Serial Old收集器
</pre>

<pre>
Parallel Old收集器
</pre>

<pre>
CMS收集器
</pre>

<pre>
G1 Garbage First收集器
</pre>

<pre>
JVM内存分配策略
</pre>
